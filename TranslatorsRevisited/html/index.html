<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Translators Revisited</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3-rc3-20030308 -->
<center>
<a class="qindex" href="index.html">Main Page</a> &nbsp; </center>
<hr><h1>Translators Revisited</h1>
<p>
<h3 align="center">August 2001</h3>Hi Dimitri,<p>
I tried to remove Config_getBool() from the translator methods, and I was successful to do it in the way that will be painless for both you and for the language maintainers now. The following sources were modified: classdef.cpp, classlist.cpp, index.cpp, optimc.cpp, packagedef.cpp, rtfgen.cpp. The optimc.h and optimc.cpp were added. The modification is very simple and errorproof. See <a class="el" href="index.html#solution_optimc">details of the solution</a>.<p>
The translator.h, translator_en.h, and translator_adapter.h were updated. The other translator_xx.h were changed only to derive from the TranslatorAdapterCVS instead of the Translator.<p>
This is another step towards new implementation of translators. If you accept this, the language maintainers should be sent some explanation. ("Damn, why it was changed again?" ;-) Possibly, the time has come to send this document to doxygen-develop.<p>
See you, Petr<p>
<hr>
 This document suggests new implementation or replacement of Translator based classes for producing language-specific strings, sentences, and information. It is a subject of the discussion. Some implementation steps were already done.<p>
<dl compact><dt><b>Author:</b></dt><dd>Petr Prikryl <p>
Dimitri van Heesch</dd></dl>
<h2><a name="Changes"></a>
Changes</h2>
(Last changes first.)<p>
<dl compact><dt><b>2001/09/23</b></dt><dd><ul>
<li><a class="el" href="index.html#PreparingDoxygen">Preparing Doxygen for changes</a> updated. The Config_getBool() removed from the translator methods -- documented <a class="el" href="index.html#solution_optimc">here</a>. The following core sources were changed: classdef.cpp, classlist.cpp, index.cpp, optimc.cpp, packagedef.cpp, rtfgen.cpp.</li><li><a class="el" href="index.html#motivation">Motivation</a> updated.</li><li><a class="el" href="index.html#questions">The questions</a> updated.</li><li><a class="el" href="index.html#EntityApproach">Entity based solution</a> slightly updated.</li><li>Minor updates elsewhere.</li></ul>
</dd></dl>
<dl compact><dt><b>2001/09/17</b></dt><dd><ul>
<li>More details related to <a class="el" href="index.html#IApplicTemplate">Application of template entities</a>. Processing instructions introduced.</li><li>New subsection: <a class="el" href="index.html#PreparingDoxygen">Preparing Doxygen for changes</a></li><li><a class="el" href="index.html#DefEntityFileSyntax">Syntax of files with entity definitions</a> updated.</li></ul>
</dd></dl>
<dl compact><dt><b>20001/09/16</b></dt><dd><ul>
<li>Title changed</li><li>First step towards XML-like entity definitions. The syntax of entity definition can be taken from XML without changes. Examples in this document updated.</li><li>Conversion program updated; C variants of texts added.</li><li><a class="el" href="index.html#DefEntityFileSyntax">Syntax of files with entity definitions</a> updated.</li><li>More details added to <a class="el" href="index.html#SupportScript">Implement the script for maintenance</a>.</li></ul>
</dd></dl>
<h2><a name="TOC"></a>
Table of contents</h2>
<ul>
<li><a class="el" href="index.html#motivation">Motivation</a></li><li><a class="el" href="index.html#questions">The questions</a></li><li><a class="el" href="index.html#CurrentMechanismAnalysis">The analysis of the curent mechanism</a></li><li><a class="el" href="index.html#EntityApproach">Entity based solution</a></li><li><a class="el" href="index.html#LanguageRelated">Language-related issues</a></li><li><a class="el" href="index.html#LanguageIndependent">Language-independent issues</a></li><li><a class="el" href="index.html#GenerDoxEntities">Automatic generation of doxygen entities</a></li><li><a class="el" href="index.html#DevelopmentStages">Development stages</a><ul>
<li><a class="el" href="index.html#StudyXML">Gaining the XML-related knowledge</a></li><li><a class="el" href="index.html#FinishingThis">Finishing this document</a></li><li><a class="el" href="index.html#PreparingDoxygen">Preparing Doxygen for changes</a></li><li><a class="el" href="index.html#FindDevelopers">Search for developers (?)</a></li><li><a class="el" href="index.html#DefEntityFileSyntax">Syntax of files with entity definitions</a></li><li><a class="el" href="index.html#IDoxEntGenerator">Implement the generator of doxygen entities</a></li><li><a class="el" href="index.html#TranslatorExp">Implement the experimental translator</a></li><li><a class="el" href="index.html#ISimpleEnt">Implement simple entities</a></li><li><a class="el" href="index.html#ISimpleEntReplacement">Implement a simple entity replacement</a></li><li><a class="el" href="index.html#ITemplateEnt">Implement template entities</a></li><li><a class="el" href="index.html#IApplicTemplate">Application of template entities</a></li><li><a class="el" href="index.html#NewTranslator">Introduce the new, single Translator class</a></li><li><a class="el" href="index.html#SupportScript">Implement the script for maintenance</a></li><li><a class="el" href="index.html#RemovingTranslator">Remove the Translator class</a></li></ul>
</li></ul>
<h2><a name="motivation"></a>
Motivation</h2>
Language support is now implemented via classes based on the abstract class <code>Translator</code>. The main reason is that, generally, it is difficult to produce nicely readable sentences from <em>fragments</em> of the chosen language.<p>
It is impossible to generalize the process of gluing the fragments together independently on the language. It's because the language rules cannot be generally algoritmized. Often, the whole sentences must be generated. It was found easier to do it programmatically, because the language maintainer can modify the sentence according to the passed arguments.<p>
Basically, the generated sequences may contain document-related generated parts, e.g. single identifiers or lists of identifiers. The generated sentences and fragments may be modified via argument values like <code>first_capital</code>, <code>plural</code>, etc.<p>
On the other hand, it would be much easier for the language maintainers or even for end users to maintain the language via editing text files, without need to recompile whole doxygen.<p>
The idea is based on implementing a mechanism that will use <em>templates for whole sentences</em>. The fundamental question is <b>How?</b><h2><a name="questions"></a>
The questions</h2>
Here are the more detailed questions. The questions were already partly answered, and some implementation work just begun to proof the design.<p>
<dl>
<dt><a name="Q1"/></a> <b>Q1: Can the language information be moved from code to files?</b> </dt>
<dd>Can any new language be introduced without need for compilation of doxygen? This question will be answered <em>yes</em> or <em>no</em>, depending on the answer to <a class="el" href="index.html#Q2">the second question</a>.<p>
</dd>
<dt><a name="Q2"/></a> <b>Q2: How the mechanism should look like?</b> </dt>
<dd>Some work to answer that was already done. See the <a class="el" href="index.html#CurrentMechanismAnalysis">The analysis of the curent mechanism</a> and <a class="el" href="index.html#EntityApproach">Entity based solution</a>.<p>
</dd>
<dt><a name="Q3"/></a> <b>Q3: Is it possible to implement the mechanism with reasonable effort in reasonable time?</b> </dt>
<dd>In other words, we should be rather conservative (feet on the ground). If the mechanism will not be clearly implementable, it should not be implemented at all.<p>
The <a class="el" href="index.html#EntityApproach">Entity based approach</a> seems to be acceptable and implementable. One of the main purposes of this document is to discuss the details or to find the problems. Part of the answer is based on <a class="el" href="index.html#GenerDoxEntities">Automatic generation of doxygen entities</a>.<p>
</dd>
<dt><a name="Q4"/></a> <b>Q4: Can the mechanism be introduced gradually to doxygen?</b> </dt>
<dd>It definitely is important to be able to test the new implementation and possibly compare the results with those generated using the old approach. It must also be possible to implement some laguages in the old way and some in the new way -- at least during testing, until the results will be the same (or very acceptable).<p>
The answer is roughly sketched in the <a class="el" href="index.html#DevelopmentStages">description of the development stages</a>.<p>
</dd>
<dt><a name="Q5"/></a> <b>Q5: Can the language maintenance be supported somehow?</b> </dt>
<dd>Since the introduction of the <code>TranslatorAdapter</code> classes, the language maintaintenance and the core development could be <em>decoupled</em>. Any language maintainer could not slow-down the core development by not implementing something which is required for compilation. This worked also in the pre-adapter era. But after introduction of the translator adapters, the translator methods can change also the interface dramatically while still using the work done by the language maintainers for the older implementation of the language specific translations.<p>
Moreover, the status of the language support can be discovered automatically. The <code>translator.pl</code> script is able to show the status of the language support for all languages. It also produces <code>translator_report.txt</code> which lists what should be implemented (new things) or removed (obsolete things). <a class="el" href="index.html#SupportScript">Similar support</a> should be implemented also for the new mechanism.<p>
</dd>
</dl>
<h2><a name="CurrentMechanismAnalysis"></a>
The analysis of the curent mechanism</h2>
The core of the solution will be based on the observation that calling the <code>trSimpleMethods()</code> of the <code>Translator</code> based classes can be seen as asking for the content of the references to the <em>language dependent</em> entities. We can think about the code inside such methods as about extremely simple algorithm that replaces the entity reference (the call) to the simple text string. The string is stored as a string literal near the code. The <code>trRelatedFunctionstrRelatedFunctions()</code> can be the typical example.<p>
Some of the <code>trAlmostSimpleMethods()</code> behave as if they contained <em>more</em> entities. If we consider the boolean like argument values (for example) to be part of the name of the entity, then the method contains that many entity definitions how many combinations of the arguments are used. Because of that, we can think about the code as about some very specialized algorithm for selection of one entity from the fixed set of entities. The <code>trFile()</code> could be the typical example, and the <code>trFile(true,false)</code>, <code>trFile(false,true)</code>, and so on could be seen as special names of internally selected entity definitions.<p>
The <code>trMoreComplexMethods()</code> generate a text string where certain parts of the output were introduced through arguments as very variable part of the content (like a line number or some identifier). The variable content is always placed into well known place inside the generated text. The surrounding text is language dependent. If there is more than one variable argument, then also the order of application of the arguments inside the generated text may be language dependent. So, we may think about the data content of such a method as about some <em>template string with markers</em> for placement the first, second, and-so-on arguments. In the same time, we may think about such a method as about a specialized algorithm that gets the template and replaces the markers by variable arguments. The <code>trCollaborationDiagram()</code> could be the typical example. The <code>trDefinedAtLineInSourceFile()</code> could be another example -- here the replacement of markers is done in the doxygen generators (which is a bit closer to the final solution). Both examples could be converted to the other one.<p>
As in the case of simple methods, we can think about a subset of the complex methods as if they contained <em>a set of templates</em>. Then, the alorithm implements also selection of the right template.<p>
<a name="SummaryCurrentMechanism"/></a> To summarize the current mechanism, there are basically four types of <code>trMethods()</code> that should be replaced by the new solution. (There is one exception, the <code>trWriteList()</code>, but it can be moved to the language independent part when we define three simple language-dependent entities used as list-item separators.) In each of the four cases, the <code>trMethod()</code> implements three basic things:<p>
<ol>
<li><em>Data store</em> is implemented via string literals.</li><li><em>Selection mechanism</em> does access one entity or one entity template of some set. In the simple case, the set contains only one element. Then the selection mechanism is trivial.</li><li><em>Replacement mechanism</em> replaces special markers inside the template entity by a variable string argument. In the case of simple entities, the mechanism is trivial (no operation). The result of replacement is then returned as the result of the method.</li></ol>
<h2><a name="EntityApproach"></a>
Entity based solution</h2>
The solution should transform the usage of <code>trMethods()</code> to textual <code></code>  with definitions read from textual files. With respect to the previous summary, the <em>data store</em> will be changed from the string literals inside the code to the external files. This way the data store will be uncoupled from the code. As the files will probably be read only once, then the complexity of the format is not a problem. I feel that---also with respect to growing importance of XML---the definition of entities should be stored in XML oriented way. Partly because the authors of XML were thinking about many problems that we want to solve (and they have already solved them), partly because growing comunity of developers will understand what is going on, and partly because there possibly are some libraries to cope with such files.<p>
The <em>selection mechanism</em>, which is responsible for retrieving the desired entity or the template entity will partly be implemented via memory structures that will be filled with the entity definitions read from the external data store (files). In general case, the memory structure should be map-like structure. The entity (or template entity) definition will be accessed using the key -- the entity name. If there is some XML related library for building and accessing entity definitions, then we should use it.<p>
The <em>replacement mechanism</em> will implement searching for template markers inside the content of a template entity and it will replace it with the arguments. The question still is, how the template arguments will be represented in the text together with the template-entity reference (syntactically). It seems that the <em>processing instructions</em> could be used in generated, language-independent XML intermediate document. That could be converted into the language dependent document of the chosen format using XML transformation tools. But this is a long-term goal. Until then, the translator class will be used to implement the part that would be done by the interpretation of the processing instructions.<p>
Thinking about the entity approach, the replacement mechanism should be also able to expand the entity references used inside another entity definition. Again, if there is some XML related library to do such things, then we should use it.<p>
To summarize the entity approach, the mechanism should generalize what is already done by doxygen. and what is <a class="el" href="index.html#SummaryCurrentMechanism">summarized</a> at the end of the <a class="el" href="index.html#CurrentMechanismAnalysis">analysis of the current mechanism</a>. So, it must implement the <em>data store</em>, the <em>selection mechanism</em>, and the <em>replacement mechanism</em>.<h2><a name="LanguageRelated"></a>
Language-related issues</h2>
The <a class="el" href="index.html#EntityApproach">outline of the entity-based solution</a> shows how the code of <code>trMethods()</code> could be separated from data and how both the code and the data structure could be generalized. However, it still does not say, how the language support should be solved.<p>
Apparently, all of the language-specific Translator-based classes could be replaced using the mentioned mechanism. Only the <em>data store</em> part will be language dependent. Instead of instantiation of the chosen translator class, the files with entity definitions for the chosen language will be loaded.<p>
The question is, whether it should happen similarly like in the current version of doxygen, or whether we could find some advantage related to the new approach. Parts of the answer can be revealed during next work on <a class="el" href="index.html#DevelopmentStages">Development stages</a>. Parts of the answer may know you, because you know the internals of doxygen more than anybody else. My guess is that we should postpone the language-dependent processing of a document to as late time as possible. We should be oriented towards some internal, language independent, and final output form independent intermediate format that will be converted to language dependent form only by the final-output generators.<p>
Another important question is how to convert the work already done by current language maintainers into definitions of the language-dependent entities. The problem was already stated in <a class="el" href="index.html#Q3">the third</a> and in <a class="el" href="index.html#Q4">the fourth</a> questions. Some ideas and procedures are shown in <a class="el" href="index.html#GenerDoxEntities">Automatic generation of doxygen entities</a> and <a class="el" href="index.html#DevelopmentStages">Development stages</a>.<h2><a name="LanguageIndependent"></a>
Language-independent issues</h2>
I guess that the generalized mechanism could be used also for generators of the final output forms (HTML, RTF, LaTeX, etc.).<p>
The more I think about it, the more it looks that many of the problems that I am thinking about could be solved using pure XML as the intermediate format and using XML transformation tools for transformation of the intermediate form into the final output formats.<p>
On the other hand, I feel that we should do smaler steps to the final solution than to remake everything into XML. Surely, if something is easy to implement in XML-like way, we should try to do it this way.<h2><a name="GenerDoxEntities"></a>
Automatic generation of doxygen entities</h2>
This section should give the answer to <a class="el" href="index.html#Q3">the third question</a>.<p>
It is possible to create a simple program that instantiates all of the language translators. Then it calls all the interesting methods of the translator and writes the result into a textual file like the following -- see below.<p>
If we can think about some argument of the <code>trMethod()</code> as about a hint for the <em>selection mechanism</em> (see <a class="el" href="index.html#CurrentMechanismAnalysis">above</a>), then we could rewrite the <code>trMethod()</code> into so many methods, how many entity definitions could be recognized inside. In other words, one <code>trMethod()</code> can be converted to more than one entity definition.<p>
If we can think about some argument as a variable argument, we can use a marker when calling the <code>trMethod()</code> as the argument value.<p>
I tried to create a very simplified program like that. Look at the results below. Pay attention to the roughly described categories and notices, then go to <a class="el" href="index.html#DoxEntSummary">summary</a>. Here is the output generated using the English and the Dutch translators:<p>
<div class="fragment"><pre>&lt;?xml encoding="iso-8859-1"?&gt;
&lt;!-- english --&gt;

&lt;!-- Simple entities --&gt;

&lt;!ENTITY trAlphabeticalList "Alphabetical List" &gt;
&lt;!ENTITY idLanguage "english" &gt;
&lt;!ENTITY latexLanguageSupportCommand "" &gt;
&lt;!ENTITY idLanguageCharset "iso-8859-1" &gt;
&lt;!ENTITY trRelatedFunctions "Related Functions" &gt;
&lt;!ENTITY trRelatedSubscript "(Note that these are not member functions.)" &gt;
&lt;!ENTITY trDetailedDescription "Detailed Description" &gt;
&lt;!ENTITY trMemberTypedefDocumentation "Member Typedef Documentation" &gt;
&lt;!ENTITY trMemberEnumerationDocumentation "Member Enumeration Documentation" &gt;
&lt;!ENTITY trMemberFunctionDocumentation "Member Function Documentation" &gt;
&lt;!ENTITY trMemberDataDocumentationC "Field Documentation" &gt;
&lt;!ENTITY trMemberDataDocumentation "Member Data Documentation" &gt;
&lt;!ENTITY trMore "More..." &gt;
&lt;!ENTITY trListOfAllMembers "List of all members." &gt;
&lt;!ENTITY trMemberList "Member List" &gt;
&lt;!ENTITY trEnumName "enum name" &gt;
&lt;!ENTITY trEnumValue "enum value" &gt;
&lt;!ENTITY trDefinedIn "defined in" &gt;
&lt;!ENTITY trModules "Modules" &gt;
&lt;!ENTITY trClassHierarchy "Class Hierarchy" &gt;
&lt;!ENTITY trCompoundListC "Data Structures" &gt;
&lt;!ENTITY trCompoundList "Compound List" &gt;
&lt;!ENTITY trFileList "File List" &gt;
&lt;!ENTITY trHeaderFilesC "Header Files" &gt;
&lt;!ENTITY trHeaderFiles "Header Files" &gt;
&lt;!ENTITY trCompoundMembers "Compound Members" &gt;
&lt;!ENTITY trFileMembersC "Globals" &gt;
&lt;!ENTITY trFileMembers "File Members" &gt;
&lt;!ENTITY trRelatedPages "Related Pages" &gt;
&lt;!ENTITY trExamples "Examples" &gt;
&lt;!ENTITY trSearch "Search" &gt;
&lt;!ENTITY trClassHierarchyDescription "This inheritance list is sorted roughly, but not completely, alphabetically:" &gt;
&lt;!ENTITY trCompoundListDescriptionC "Here are the data structures with brief descriptions:" &gt;
&lt;!ENTITY trCompoundListDescription "Here are the classes, structs, unions and interfaces with brief descriptions:" &gt;
&lt;!ENTITY trHeaderFilesDescription "Here are the header files that make up the API:" &gt;
&lt;!ENTITY trExamplesDescription "Here is a list of all examples:" &gt;
&lt;!ENTITY trRelatedPagesDescription "Here is a list of all related documentation pages:" &gt;
&lt;!ENTITY trModulesDescription "Here is a list of all modules:" &gt;
&lt;!ENTITY trNoDescriptionAvailable "No description available" &gt;
&lt;!ENTITY trDocumentation "Documentation" &gt;
&lt;!ENTITY trModuleIndex "Module Index" &gt;
&lt;!ENTITY trHierarchicalIndex "Hierarchical Index" &gt;
&lt;!ENTITY trCompoundIndexC "Data Structure Index" &gt;
&lt;!ENTITY trCompoundIndex "Compound Index" &gt;
&lt;!ENTITY trFileIndex "File Index" &gt;
&lt;!ENTITY trModuleDocumentation "Module Documentation" &gt;
&lt;!ENTITY trClassDocumentationC "Data Structure Documentation" &gt;
&lt;!ENTITY trClassDocumentation "Class Documentation" &gt;
&lt;!ENTITY trFileDocumentation "File Documentation" &gt;
&lt;!ENTITY trExampleDocumentation "Example Documentation" &gt;
&lt;!ENTITY trPageDocumentation "Page Documentation" &gt;
&lt;!ENTITY trReferenceManual "Reference Manual" &gt;
&lt;!ENTITY trDefines "Defines" &gt;
&lt;!ENTITY trFuncProtos "Function Prototypes" &gt;
&lt;!ENTITY trTypedefs "Typedefs" &gt;
&lt;!ENTITY trEnumerations "Enumerations" &gt;
&lt;!ENTITY trFunctions "Functions" &gt;
&lt;!ENTITY trVariables "Variables" &gt;
&lt;!ENTITY trEnumerationValues "Enumeration values" &gt;
&lt;!ENTITY trDefineDocumentation "Define Documentation" &gt;
&lt;!ENTITY trFunctionPrototypeDocumentation "Function Prototype Documentation" &gt;
&lt;!ENTITY trTypedefDocumentation "Typedef Documentation" &gt;
&lt;!ENTITY trEnumerationTypeDocumentation "Enumeration Type Documentation" &gt;
&lt;!ENTITY trEnumerationValueDocumentation "Enumeration Value Documentation" &gt;
&lt;!ENTITY trFunctionDocumentation "Function Documentation" &gt;
&lt;!ENTITY trVariableDocumentation "Variable Documentation" &gt;
&lt;!ENTITY trCompoundsC "Data Structures" &gt;
&lt;!ENTITY trCompounds "Compounds" &gt;
&lt;!ENTITY trWrittenBy "written by" &gt;
&lt;!ENTITY trForInternalUseOnly "For internal use only." &gt;
&lt;!ENTITY trReimplementedForInternalReasons "Reimplemented for internal reasons; the API is not affected." &gt;
&lt;!ENTITY trWarning "Warning" &gt;
&lt;!ENTITY trBugsAndLimitations "Bugs and limitations" &gt;
&lt;!ENTITY trVersion "Version" &gt;
&lt;!ENTITY trDate "Date" &gt;
&lt;!ENTITY trReturns "Returns" &gt;
&lt;!ENTITY trSeeAlso "See also" &gt;
&lt;!ENTITY trParameters "Parameters" &gt;
&lt;!ENTITY trExceptions "Exceptions" &gt;
&lt;!ENTITY trGeneratedBy "Generated by" &gt;
&lt;!ENTITY trNamespaceList "Namespace List" &gt;
&lt;!ENTITY trFriends "Friends" &gt;
&lt;!ENTITY trRelatedFunctionDocumentation "Friends And Related Function Documentation" &gt;
&lt;!ENTITY trPublicMembers "Public Methods" &gt;
&lt;!ENTITY trPublicSlots "Public Slots" &gt;
&lt;!ENTITY trSignals "Signals" &gt;
&lt;!ENTITY trStaticPublicMembers "Static Public Methods" &gt;
&lt;!ENTITY trProtectedMembers "Protected Methods" &gt;
&lt;!ENTITY trProtectedSlots "Protected Slots" &gt;
&lt;!ENTITY trStaticProtectedMembers "Static Protected Methods" &gt;
&lt;!ENTITY trPrivateMembers "Private Methods" &gt;
&lt;!ENTITY trPrivateSlots "Private Slots" &gt;
&lt;!ENTITY trStaticPrivateMembers "Static Private Methods" &gt;
&lt;!ENTITY trNamespaceMembers "Namespace Members" &gt;
&lt;!ENTITY trNamespaceIndex "Namespace Index" &gt;
&lt;!ENTITY trNamespaceDocumentation "Namespace Documentation" &gt;
&lt;!ENTITY trNamespaces "Namespaces" &gt;
&lt;!ENTITY trAlphabeticalList "Alphabetical List" &gt;
&lt;!ENTITY trReturnValues "Return values" &gt;
&lt;!ENTITY trMainPage "Main Page" &gt;
&lt;!ENTITY trPageAbbreviation "p." &gt;
&lt;!ENTITY trSources "Sources" &gt;
&lt;!ENTITY trDeprecated "Deprecated" &gt;
&lt;!ENTITY trConstructorDocumentation "Constructor &amp; Destructor Documentation" &gt;
&lt;!ENTITY trGotoSourceCode "Go to the source code of this file." &gt;
&lt;!ENTITY trGotoDocumentation "Go to the documentation of this file." &gt;
&lt;!ENTITY trPrecondition "Precondition" &gt;
&lt;!ENTITY trPostcondition "Postcondition" &gt;
&lt;!ENTITY trInvariant "Invariant" &gt;
&lt;!ENTITY trInitialValue "Initial value:" &gt;
&lt;!ENTITY trCode "code" &gt;
&lt;!ENTITY trGraphicalHierarchy "Graphical Class Hierarchy" &gt;
&lt;!ENTITY trGotoGraphicalHierarchy "Go to the graphical class hierarchy" &gt;
&lt;!ENTITY trGotoTextualHierarchy "Go to the textual class hierarchy" &gt;
&lt;!ENTITY trPageIndex "Page Index" &gt;
&lt;!ENTITY trNote "Note" &gt;
&lt;!ENTITY trPublicTypes "Public Types" &gt;
&lt;!ENTITY trPublicAttribsC "Data Fields" &gt;
&lt;!ENTITY trPublicAttribs "Public Attributes" &gt;
&lt;!ENTITY trStaticPublicAttribs "Static Public Attributes" &gt;
&lt;!ENTITY trProtectedTypes "Protected Types" &gt;
&lt;!ENTITY trProtectedAttribs "Protected Attributes" &gt;
&lt;!ENTITY trStaticProtectedAttribs "Static Protected Attributes" &gt;
&lt;!ENTITY trPrivateTypes "Private Types" &gt;
&lt;!ENTITY trPrivateAttribs "Private Attributes" &gt;
&lt;!ENTITY trStaticPrivateAttribs "Static Private Attributes" &gt;
&lt;!ENTITY trTodo "Todo" &gt;
&lt;!ENTITY trTodoList "Todo List" &gt;
&lt;!ENTITY trReferencedBy "Referenced by" &gt;
&lt;!ENTITY trRemarks "Remarks" &gt;
&lt;!ENTITY trAttention "Attention" &gt;
&lt;!ENTITY trInclByDepGraph "This graph shows which files directly or indirectly include this file:" &gt;
&lt;!ENTITY trSince "Since" &gt;
&lt;!ENTITY trLegendTitle "Graph Legend" &gt;
&lt;!ENTITY trLegendDocs &lt;![CDATA[This page explains how to interpret the graphs that are generated by doxygen.&lt;p&gt;
Consider the following example:
\code
/*! Invisible class because of truncation */
class Invisible { };

/*! Truncated class, inheritance relation is hidden */
class Truncated : public Invisible { };

/* Class not documented with doxygen comments */
class Undocumented { };

/*! Class that is inherited using public inheritance */
class PublicBase : public Truncated { };

/*! Class that is inherited using protected inheritance */
class ProtectedBase { };

/*! Class that is inherited using private inheritance */
class PrivateBase { };

/*! Class that is used by the Inherited class */
class Used { };

/*! Super class that inherits a number of other classes */
class Inherited : public PublicBase,
                  protected ProtectedBase,
                  private PrivateBase,
                  public Undocumented
{
  private:
    Used *m_usedClass;
};
\endcode
If the \c MAX_DOT_GRAPH_HEIGHT tag in the configuration file is set to 200 this will result in the following graph:&lt;p&gt;&lt;center&gt;&lt;img src="graph_legend.gif"&gt;&lt;/center&gt;
&lt;p&gt;
The boxes in the above graph have the following meaning:
&lt;ul&gt;
&lt;li&gt;%A filled black box represents the struct or class for which the graph is generated.
&lt;li&gt;%A box with a black border denotes a documented struct or class.
&lt;li&gt;%A box with a grey border denotes an undocumented struct or class.
&lt;li&gt;%A box with a red border denotes a documented struct or class for
which not all inheritance/containment relations are shown. %A graph is truncated if it does not fit within the specified boundaries.&lt;/ul&gt;
The arrows have the following meaning:
&lt;ul&gt;
&lt;li&gt;%A dark blue arrow is used to visualize a public inheritance relation between two classes.
&lt;li&gt;%A dark green arrow is used for protected inheritance.
&lt;li&gt;%A dark red arrow is used for private inheritance.
&lt;li&gt;%A purple dashed arrow is used if a class is contained or used by another class. The arrow is labeled with the variable(s) through which the pointed class or struct is accessible. 
&lt;/ul&gt;
]]&gt; &gt;
&lt;!ENTITY trLegend "legend" &gt;
&lt;!ENTITY trTest "Test" &gt;
&lt;!ENTITY trTestList "Test List" &gt;
&lt;!ENTITY trDCOPMethods "DCOP Methods" &gt;
&lt;!ENTITY trProperties "Properties" &gt;
&lt;!ENTITY trPropertyDocumentation "Property Documentation" &gt;
&lt;!ENTITY trInterfaces "Interfaces" &gt;
&lt;!ENTITY trClassesC "Data Structures" &gt;
&lt;!ENTITY trClasses "Classes" &gt;
&lt;!ENTITY trPackageList "Package List" &gt;
&lt;!ENTITY trPackageListDescription "Here are the packages with brief descriptions (if available):" &gt;
&lt;!ENTITY trPackages "Packages" &gt;
&lt;!ENTITY trPackageDocumentation "Package Documentation" &gt;
&lt;!ENTITY trDefineValue "Value:" &gt;
&lt;!ENTITY trBug "Bug" &gt;
&lt;!ENTITY trBugList "Bug List" &gt;
&lt;!ENTITY trRTFansicp "1252" &gt;
&lt;!ENTITY trRTFCharSet "0" &gt;
&lt;!ENTITY trRTFGeneralIndex "Index" &gt;

&lt;!-- Sets of simple entities --&gt;
&lt;!ENTITY trFileListDescriptionF "Here is a list of all documented files with brief descriptions:" &gt;
&lt;!ENTITY trFileListDescriptionT "Here is a list of all files with brief descriptions:" &gt;
&lt;!-- --&gt;
&lt;!ENTITY trCompoundMembersDescriptionFC "Here is a list of all documented struct and union fields with links to the structures/unions they belong to:" &gt;
&lt;!ENTITY trCompoundMembersDescriptionTC "Here is a list of all struct and union fields with links to the struct/union documentation for each field:" &gt;
&lt;!ENTITY trCompoundMembersDescriptionF "Here is a list of all documented class members with links to the classes they belong to:" &gt;
&lt;!ENTITY trCompoundMembersDescriptionT "Here is a list of all class members with links to the class documentation for each member:" &gt;
&lt;!-- --&gt;
&lt;!ENTITY trFileMembersDescriptionFC "Here is a list of all documented functions, variables, defines, enums, and typedefs with links to the documentation:" &gt;
&lt;!ENTITY trFileMembersDescriptionTC "Here is a list of all functions, variables, defines, enums, and typedefs with links to the files they belong to:" &gt;
&lt;!ENTITY trFileMembersDescriptionF "Here is a list of all documented file members with links to the documentation:" &gt;
&lt;!ENTITY trFileMembersDescriptionT "Here is a list of all file members with links to the files they belong to:" &gt;
&lt;!-- --&gt;
&lt;!ENTITY trNamespaceListDescriptionF "Here is a list of all documented namespaces with brief descriptions:" &gt;
&lt;!ENTITY trNamespaceListDescriptionT "Here is a list of all namespaces with brief descriptions:" &gt;
&lt;!-- --&gt;
&lt;!ENTITY trNamespaceMemberDescriptionF "Here is a list of all documented namespace members with links to the namespaces they belong to:" &gt;
&lt;!ENTITY trNamespaceMemberDescriptionT "Here is a list of all namespace members with links to the namespace documentation for each member:" &gt;
&lt;!-- --&gt;
&lt;!ENTITY trclass "class" &gt;
&lt;!ENTITY trclasses "classes" &gt;
&lt;!ENTITY trClass "Class" &gt;
&lt;!ENTITY trClasses "Classes" &gt;
&lt;!-- --&gt;
&lt;!ENTITY trfile "file" &gt;
&lt;!ENTITY trfiles "files" &gt;
&lt;!ENTITY trFile "File" &gt;
&lt;!ENTITY trFiles "Files" &gt;
&lt;!-- --&gt;
&lt;!ENTITY trnamespace "namespace" &gt;
&lt;!ENTITY trnamespaces "namespaces" &gt;
&lt;!ENTITY trNamespace "Namespace" &gt;
&lt;!ENTITY trNamespaces "Namespaces" &gt;
&lt;!-- --&gt;
&lt;!ENTITY trgroup "group" &gt;
&lt;!ENTITY trgroups "groups" &gt;
&lt;!ENTITY trGroup "Group" &gt;
&lt;!ENTITY trGroups "Groups" &gt;
&lt;!-- --&gt;
&lt;!ENTITY trpage "page" &gt;
&lt;!ENTITY trpages "pages" &gt;
&lt;!ENTITY trPage "Page" &gt;
&lt;!ENTITY trPages "Pages" &gt;
&lt;!-- --&gt;
&lt;!ENTITY trmember "member" &gt;
&lt;!ENTITY trmembers "members" &gt;
&lt;!ENTITY trMember "Member" &gt;
&lt;!ENTITY trMembers "Members" &gt;
&lt;!-- --&gt;
&lt;!ENTITY trfield "field" &gt;
&lt;!ENTITY trfields "fields" &gt;
&lt;!ENTITY trField "Field" &gt;
&lt;!ENTITY trFields "Fields" &gt;
&lt;!-- --&gt;
&lt;!ENTITY trglobal "global" &gt;
&lt;!ENTITY trglobals "globals" &gt;
&lt;!ENTITY trGlobal "Global" &gt;
&lt;!ENTITY trGlobals "Globals" &gt;
&lt;!-- --&gt;
&lt;!ENTITY trauthor "author" &gt;
&lt;!ENTITY trauthors "authors" &gt;
&lt;!ENTITY trAuthor "Author" &gt;
&lt;!ENTITY trAuthors "Authors" &gt;
&lt;!-- --&gt;
&lt;!ENTITY trClassDocGeneratedFromFile "The documentation for this class was generated from the following file:" &gt;
&lt;!ENTITY trClassDocGeneratedFromFiles "The documentation for this class was generated from the following files:" &gt;

&lt;!ENTITY trStructDocGeneratedFromFile "The documentation for this struct was generated from the following file:" &gt;
&lt;!ENTITY trStructDocGeneratedFromFiles "The documentation for this struct was generated from the following files:" &gt;

&lt;!ENTITY trUnionDocGeneratedFromFile "The documentation for this union was generated from the following file:" &gt;
&lt;!ENTITY trUnionDocGeneratedFromFiles "The documentation for this union was generated from the following files:" &gt;

&lt;!ENTITY trInterfaceDocGeneratedFromFile "The documentation for this interface was generated from the following file:" &gt;
&lt;!ENTITY trInterfaceDocGeneratedFromFiles "The documentation for this interface was generated from the following files:" &gt;

&lt;!ENTITY trExceptionDocGeneratedFromFile "The documentation for this exception was generated from the following file:" &gt;
&lt;!ENTITY trExceptionDocGeneratedFromFiles "The documentation for this exception was generated from the following files:" &gt;
&lt;!-- --&gt;

------------------------------------------


&lt;!-- Template entities (or what should be) --&gt;

&lt;!ENTITY trDefinedAtLineInSourceFile "Definition at line @0 of file @1." &gt;
&lt;!ENTITY trDefinedInSourceFile "Definition in file @0." &gt;
&lt;!ENTITY trFileReference "$1 File Reference" &gt;
&lt;!ENTITY trNamespaceReference "$1 Namespace Reference" &gt;
&lt;!ENTITY trCollaborationDiagram "Collaboration diagram for $1:" &gt;
&lt;!ENTITY trInclDepGraph "Include dependency graph for $1:" &gt;
&lt;!ENTITY trPackage "Package $1" &gt;

&lt;!-- Sets of template entities --&gt;

&lt;!ENTITY trClassReference "$1  Class Reference" &gt;
&lt;!ENTITY trClassTemplateReference "$1  Class Template Reference" &gt;

&lt;!ENTITY trStructReference "$1  Struct Reference" &gt;
&lt;!ENTITY trUnionReference "$1  Union Reference" &gt;
&lt;!ENTITY trInterfaceReference "$1  Interface Reference" &gt;
&lt;!ENTITY trExceptionReference "$1  Exception Reference" &gt;

&lt;!-- Simple entities with fixed-name generated-entity references inside

&lt;!ENTITY trGeneratedAutomatically "Generated automatically by Doxygen for &amp;ProjName; from the source code." &gt;
&lt;!ENTITY trGeneratedAt "Generated at &amp;GenDate; for &amp;ProjName; by" &gt;
--&gt;

&lt;!-- ... but they can be also implemented as template entities)--&gt;

&lt;!ENTITY trGeneratedAutomatically "Generated automatically by Doxygen for $1 from the source code." &gt;
&lt;!ENTITY trGeneratedAt "Generated at $1 for $2 by" &gt;

&lt;!-- Simple fragments that should be converted to template entities --&gt;

&lt;!ENTITY trThisIsTheListOfAllMembers "This is the complete list of members for " &gt;
&lt;!ENTITY trIncludingInheritedMembers ", including all inherited members." &gt;

&lt;!-- should be converted to something like... --&gt;

&lt;!ENTITY trThisIsTheListOfAllMembers "This is the complete list of members for $1." &gt;
&lt;!ENTITY trTheListOfAllMembersIncludingInherited "This is the complete list of members for $1, including all inherited members." &gt;

&lt;! --trWriteList() should be replaced using
     &amp;trLSep;, &amp;trLSepAnd2;, and &amp;trLSepAnd; entities

&lt;!ENTITY trWriteList1 "@0" &gt;
&lt;!ENTITY trWriteList2 "@0, and @1" &gt;
&lt;!ENTITY trWriteList3 "@0, @1, and @2" &gt;
--&gt;

&lt;!ENTITY trLSep ", " &gt;
&lt;!ENTITY trLSepAnd ", and " &gt;
&lt;!ENTITY trLSepAnd2 ", and " &gt;

&lt;!-- Should be normal entity templates instead using trWriteList inside --&gt;

&lt;!--
&lt;!ENTITY trInheritsList "Inherits @0." &gt;
&lt;!ENTITY trInheritsList "Inherits @0, and @1." &gt;
&lt;!ENTITY trInheritsList "Inherits @0, @1, and @2." &gt;
--&gt;
&lt;!ENTITY trInherits "Inherits $1." &gt;
&lt;!ENTITY trInheritsList "Inherits $1." &gt;
&lt;!--
&lt;!ENTITY trInheritedByList "Inherited by @0." &gt;
&lt;!ENTITY trInheritedByList "Inherited by @0, and @1." &gt;
&lt;!ENTITY trInheritedByList "Inherited by @0, @1, and @2." &gt;
--&gt;
&lt;!ENTITY trInheritedBy "Inherited by $1." &gt;
&lt;!ENTITY trInheritedByList "Inherited by $1." &gt;
&lt;!--
&lt;!ENTITY trReimplementedFromList "Reimplemented from @0." &gt;
&lt;!ENTITY trReimplementedFromList "Reimplemented from @0, and @1." &gt;
&lt;!ENTITY trReimplementedFromList "Reimplemented from @0, @1, and @2." &gt;
--&gt;
&lt;!ENTITY trReimplementedFrom "Reimplemented from $1." &gt;
&lt;!ENTITY trReimplementedFromList "Reimplemented from $1." &gt;
&lt;!--
&lt;!ENTITY trReimplementedInList "Reimplemented in @0." &gt;
&lt;!ENTITY trReimplementedInList "Reimplemented in @0, and @1." &gt;
&lt;!ENTITY trReimplementedInList "Reimplemented in @0, @1, and @2." &gt;
--&gt;
&lt;!ENTITY trReimplementedIn "Reimplemented in $1." &gt;
&lt;!ENTITY trReimplementedInList "Reimplemented in $1." &gt;

&lt;!-- (end) --&gt;
</pre></div><p>
And now the same for Dutch:<p>
<div class="fragment"><pre>&lt;?xml encoding="iso-8859-1"?&gt;
&lt;!-- dutch --&gt;

&lt;!-- Simple entities --&gt;

&lt;!ENTITY trAlphabeticalList "Alphabetical List" &gt;
&lt;!ENTITY idLanguage "dutch" &gt;
&lt;!ENTITY latexLanguageSupportCommand &lt;![CDATA[\usepackage[dutch]{babel}
]]&gt; &gt;
&lt;!ENTITY idLanguageCharset "iso-8859-1" &gt;
&lt;!ENTITY trRelatedFunctions "Gerelateerde functies" &gt;
&lt;!ENTITY trRelatedSubscript "(Merk op dat dit geen member functies zijn.)" &gt;
&lt;!ENTITY trDetailedDescription "Gedetailleerde Beschrijving" &gt;
&lt;!ENTITY trMemberTypedefDocumentation "Documentatie van type definitie members" &gt;
&lt;!ENTITY trMemberEnumerationDocumentation "Documentatie van enumeratie members" &gt;
&lt;!ENTITY trMemberFunctionDocumentation "Documentatie van functie members" &gt;
&lt;!ENTITY trMemberDataDocumentationC "Documentatie van data members" &gt;
&lt;!ENTITY trMemberDataDocumentation "Documentatie van data members" &gt;
&lt;!ENTITY trMore "Meer..." &gt;
&lt;!ENTITY trListOfAllMembers "Lijst van alle members." &gt;
&lt;!ENTITY trMemberList "Member Lijst" &gt;
&lt;!ENTITY trEnumName "enum naam" &gt;
&lt;!ENTITY trEnumValue "enum waarde" &gt;
&lt;!ENTITY trDefinedIn "gedefinieerd in" &gt;
&lt;!ENTITY trModules "Modules" &gt;
&lt;!ENTITY trClassHierarchy "Klasse Hi&amp;euml;rarchie" &gt;
&lt;!ENTITY trCompoundListC "Compound Lijst" &gt;
&lt;!ENTITY trCompoundList "Compound Lijst" &gt;
&lt;!ENTITY trFileList "File Lijst" &gt;
&lt;!ENTITY trHeaderFilesC "Header Lijst" &gt;
&lt;!ENTITY trHeaderFiles "Header Lijst" &gt;
&lt;!ENTITY trCompoundMembers "Compound Members" &gt;
&lt;!ENTITY trFileMembersC "File members" &gt;
&lt;!ENTITY trFileMembers "File members" &gt;
&lt;!ENTITY trRelatedPages "Gerelateerde pagina's" &gt;
&lt;!ENTITY trExamples "Voorbeelden" &gt;
&lt;!ENTITY trSearch "Zoeken" &gt;
&lt;!ENTITY trClassHierarchyDescription "Deze inheritance lijst is min of meer alfabetisch gesorteerd:" &gt;
&lt;!ENTITY trCompoundListDescriptionC "Hieronder volgen de klassen, structs en unions met voor elk een korte beschrijving:" &gt;
&lt;!ENTITY trCompoundListDescription "Hieronder volgen de klassen, structs en unions met voor elk een korte beschrijving:" &gt;
&lt;!ENTITY trHeaderFilesDescription "Hieronder volgen de header files die de API vormen:" &gt;
&lt;!ENTITY trExamplesDescription "Hieronder volgt de lijst met alle voorbeelden:" &gt;
&lt;!ENTITY trRelatedPagesDescription "Hieronder volgt de lijst met alle pagina's die gerelateerde documentatie bevatten:" &gt;
&lt;!ENTITY trModulesDescription "Hieronder volgt de lijst met alle modules:" &gt;
&lt;!ENTITY trNoDescriptionAvailable "Geen korte beschrijving beschikbaar" &gt;
&lt;!ENTITY trDocumentation "Documentatie" &gt;
&lt;!ENTITY trModuleIndex "Module Index" &gt;
&lt;!ENTITY trHierarchicalIndex "Hi&amp;euml;rarchische Index" &gt;
&lt;!ENTITY trCompoundIndexC "Compound Index" &gt;
&lt;!ENTITY trCompoundIndex "Compound Index" &gt;
&lt;!ENTITY trFileIndex "File Index" &gt;
&lt;!ENTITY trModuleDocumentation "Module Documentatie" &gt;
&lt;!ENTITY trClassDocumentationC "Klassen Documentatie" &gt;
&lt;!ENTITY trClassDocumentation "Klassen Documentatie" &gt;
&lt;!ENTITY trFileDocumentation "File Documentatie" &gt;
&lt;!ENTITY trExampleDocumentation "Documentatie van voorbeelden" &gt;
&lt;!ENTITY trPageDocumentation "Documentatie van gerelateerde pagina's" &gt;
&lt;!ENTITY trReferenceManual "Naslagwerk" &gt;
&lt;!ENTITY trDefines "Defines" &gt;
&lt;!ENTITY trFuncProtos "Functie Prototypes" &gt;
&lt;!ENTITY trTypedefs "Typedefs" &gt;
&lt;!ENTITY trEnumerations "Enumeraties" &gt;
&lt;!ENTITY trFunctions "Functies" &gt;
&lt;!ENTITY trVariables "Variabelen" &gt;
&lt;!ENTITY trEnumerationValues "Enumeratie waarden" &gt;
&lt;!ENTITY trDefineDocumentation "Documentatie van defines" &gt;
&lt;!ENTITY trFunctionPrototypeDocumentation "Documentatie van functie Prototypes" &gt;
&lt;!ENTITY trTypedefDocumentation "Documentatie van typedefs" &gt;
&lt;!ENTITY trEnumerationTypeDocumentation "Documentatie van enumeratie types" &gt;
&lt;!ENTITY trEnumerationValueDocumentation "Documentatie van enumeratie waarden" &gt;
&lt;!ENTITY trFunctionDocumentation "Documentatie van functies" &gt;
&lt;!ENTITY trVariableDocumentation "Documentatie van variabelen" &gt;
&lt;!ENTITY trCompoundsC "Compounds" &gt;
&lt;!ENTITY trCompounds "Compounds" &gt;
&lt;!ENTITY trWrittenBy "geschreven door" &gt;
&lt;!ENTITY trForInternalUseOnly "Alleen voor intern gebruik." &gt;
&lt;!ENTITY trReimplementedForInternalReasons "Om interne rederene opnieuwd ge&amp;iuml;mplemented; de API wordt er niet door be&amp;iuml;nvloed." &gt;
&lt;!ENTITY trWarning "Waarschuwing" &gt;
&lt;!ENTITY trBugsAndLimitations "Fouten en beperkingen" &gt;
&lt;!ENTITY trVersion "Versie" &gt;
&lt;!ENTITY trDate "Datum" &gt;
&lt;!ENTITY trReturns "Retourneert" &gt;
&lt;!ENTITY trSeeAlso "Zie ook" &gt;
&lt;!ENTITY trParameters "Parameters" &gt;
&lt;!ENTITY trExceptions "Excepties" &gt;
&lt;!ENTITY trGeneratedBy "Gegenereerd door" &gt;
&lt;!ENTITY trNamespaceList "Namespace Lijst" &gt;
&lt;!ENTITY trFriends "Friends" &gt;
&lt;!ENTITY trRelatedFunctionDocumentation "Documentatie van friends en gerelateerde functies" &gt;
&lt;!ENTITY trPublicMembers "Public Members" &gt;
&lt;!ENTITY trPublicSlots "Public Slots" &gt;
&lt;!ENTITY trSignals "Signals" &gt;
&lt;!ENTITY trStaticPublicMembers "Static Public Members" &gt;
&lt;!ENTITY trProtectedMembers "Protected Members" &gt;
&lt;!ENTITY trProtectedSlots "Protected Slots" &gt;
&lt;!ENTITY trStaticProtectedMembers "Static Protected Members" &gt;
&lt;!ENTITY trPrivateMembers "Private Members" &gt;
&lt;!ENTITY trPrivateSlots "Private Slots" &gt;
&lt;!ENTITY trStaticPrivateMembers "Static Private Members" &gt;
&lt;!ENTITY trNamespaceMembers "Namespace Members" &gt;
&lt;!ENTITY trNamespaceIndex "Namespace Index" &gt;
&lt;!ENTITY trNamespaceDocumentation "Namespace Documentatie" &gt;
&lt;!ENTITY trNamespaces "Namespaces" &gt;
&lt;!ENTITY trAlphabeticalList "Alphabetical List" &gt;
&lt;!ENTITY trReturnValues "Retour waarden" &gt;
&lt;!ENTITY trMainPage "Hoofd Pagina" &gt;
&lt;!ENTITY trPageAbbreviation "p." &gt;
&lt;!ENTITY trSources "Broncode" &gt;
&lt;!ENTITY trDeprecated "Verouderd" &gt;
&lt;!ENTITY trConstructorDocumentation "Constructor &amp; Destructor Documentatie" &gt;
&lt;!ENTITY trGotoSourceCode "Ga naar de bron code van deze file." &gt;
&lt;!ENTITY trGotoDocumentation "Ga naar de documentatie van deze file." &gt;
&lt;!ENTITY trPrecondition "Preconditie" &gt;
&lt;!ENTITY trPostcondition "Postconditie" &gt;
&lt;!ENTITY trInvariant "Invariant" &gt;
&lt;!ENTITY trInitialValue "Initi&amp;euml;le waarde:" &gt;
&lt;!ENTITY trCode "code" &gt;
&lt;!ENTITY trGraphicalHierarchy "Grafische Klasse Hi&amp;euml;rarchie" &gt;
&lt;!ENTITY trGotoGraphicalHierarchy "Ga naar de grafische klasse hi&amp;euml;rarchie" &gt;
&lt;!ENTITY trGotoTextualHierarchy "Ga naar de tekstuele klasse hi&amp;euml;rarchie" &gt;
&lt;!ENTITY trPageIndex "Pagina Index" &gt;
&lt;!ENTITY trNote "Noot" &gt;
&lt;!ENTITY trPublicTypes "Public Typen" &gt;
&lt;!ENTITY trPublicAttribsC "Public Attributen" &gt;
&lt;!ENTITY trPublicAttribs "Public Attributen" &gt;
&lt;!ENTITY trStaticPublicAttribs "Static Public Attributen" &gt;
&lt;!ENTITY trProtectedTypes "Protected Typen" &gt;
&lt;!ENTITY trProtectedAttribs "Protected Attributen" &gt;
&lt;!ENTITY trStaticProtectedAttribs "Static Protected Attributen" &gt;
&lt;!ENTITY trPrivateTypes "Private Typen" &gt;
&lt;!ENTITY trPrivateAttribs "Private Attributen" &gt;
&lt;!ENTITY trStaticPrivateAttribs "Static Private Attributen" &gt;
&lt;!ENTITY trTodo "Todo" &gt;
&lt;!ENTITY trTodoList "Todo Lijst" &gt;
&lt;!ENTITY trReferencedBy "Wordt aangeroepen door" &gt;
&lt;!ENTITY trRemarks "Opmerkingen" &gt;
&lt;!ENTITY trAttention "Attentie" &gt;
&lt;!ENTITY trInclByDepGraph "Deze graaf geeft aan welke files direct of indirect afhankelijk zijn van deze file:" &gt;
&lt;!ENTITY trSince "Sinds" &gt;
&lt;!ENTITY trLegendTitle "Graaf Legenda" &gt;
&lt;!ENTITY trLegendDocs &lt;![CDATA[Deze pagina legt uit hoe de grafen die gegenereerd worden door doxygen ge&amp;iuml;nterpreteerd dienen te worden.&lt;p&gt;
Beschouw het volgende voorbeeld:
\code
/*! Onzichtbare klasse vanwege afkappen van de graaf */
class Invisible { };

/*! Afgekapte klasse, overervingsrelatie is verborgen */
class Truncated : public Invisible { };

/* Klasse is niet gedocumenteerd met doxygen commentaar */
class Undocumented { };

/*! Klasse met public inheritance */
class PublicBase : public Truncated { };

/*! Klasse met protected inheritance */
class ProtectedBase { };

/*! Klasse met private inheritance */
class PrivateBase { };

/*! Klasse die wordt gebruikt door de klasse Inherited */
class Used { };

/*! Super klasse die overerft van een aantal andere klassen */
class Inherited : public PublicBase,
                  protected ProtectedBase,
                  private PrivateBase,
                  public Undocumented
{
  private:
    Used *m_usedClass;
};
\endcode
Als de \c MAX_DOT_GRAPH_HEIGHT tag in the configuratie file op 200 gezet is, zal het bestaande voorbeeld resulteren in de volgende graaf:&lt;p&gt;&lt;center&gt;&lt;img src="graph_legend.gif"&gt;&lt;/center&gt;
&lt;p&gt;
De rechthoeken in the bovenstaande graaf hebben de volgende betekenis:
&lt;ul&gt;
&lt;li&gt;Een gevulde zwarte rechthoek representeert de structure of klasse waarvoor de graaf is gegeneerd.
&lt;li&gt;Een rechthoek met een zwarte rand representeert een gedocumenteerde structure of klasse.
&lt;li&gt;Een rechthoek met een grijze rand representeert een ongedocumenteerde structure of klasse.
&lt;li&gt;Een rechthoek met een rode rand representeert een gedocumenteerde structure or klasse waarvoor
niet alle overervings- of gebruiksrelaties konden worden getoond. Een graaf wordt afgekapt als hij niet past binnen de gespecificeerde grenzen.&lt;/ul&gt;
De pijlen hebben de volgende betekenis:
&lt;ul&gt;
&lt;li&gt;Een donkerblauwe pijl visualizeert een public inheritance relatie tussen twee klassen.
&lt;li&gt;Een donkergroene pijl wordt gebruikt voor protected inheritance.
&lt;li&gt;Een donkerrode pijl wordt gebruikt voor private inheritance.
&lt;li&gt;Een paars gestreepte pijl wordt gebruikt indien een klasse bevat is of gebruikt wordt door een andere klasse. De pijl is gelabeled met de variable(n) die toegang geven tot de aangewezen klasse of structure. 
&lt;/ul&gt;
]]&gt; &gt;
&lt;!ENTITY trLegend "legenda" &gt;
&lt;!ENTITY trTest "Test" &gt;
&lt;!ENTITY trTestList "Test Lijst" &gt;
&lt;!ENTITY trDCOPMethods "DCOP Methoden" &gt;
&lt;!ENTITY trProperties "Properties" &gt;
&lt;!ENTITY trPropertyDocumentation "Property Documentatie" &gt;
&lt;!ENTITY trInterfaces "Interfaces" &gt;
&lt;!ENTITY trClassesC "Klassen" &gt;
&lt;!ENTITY trClasses "Klassen" &gt;
&lt;!ENTITY trPackageList "Package Lijst" &gt;
&lt;!ENTITY trPackageListDescription "Hier volgen de packages, elk met een korte beschrijving (indien aanwezig):" &gt;
&lt;!ENTITY trPackages "Packages" &gt;
&lt;!ENTITY trPackageDocumentation "Package Documentatie" &gt;
&lt;!ENTITY trDefineValue "Waarde:" &gt;
&lt;!ENTITY trBug "Bug" &gt;
&lt;!ENTITY trBugList "Bug Lijst" &gt;
&lt;!ENTITY trRTFansicp "1252" &gt;
&lt;!ENTITY trRTFCharSet "0" &gt;
&lt;!ENTITY trRTFGeneralIndex "Index" &gt;

&lt;!-- Sets of simple entities --&gt;
&lt;!ENTITY trFileListDescriptionF "Hieronder volgt de lijst met alle gedocumenteerde files, elk met een korte beschrijving:" &gt;
&lt;!ENTITY trFileListDescriptionT "Hieronder volgt de lijst met alle files, elk met een korte beschrijving:" &gt;
&lt;!-- --&gt;
&lt;!ENTITY trCompoundMembersDescriptionFC "Hieronder volgt de lijst met alle gedocumenteerde klasse members met links naar de klassen waartoe ze behoren:" &gt;
&lt;!ENTITY trCompoundMembersDescriptionTC "Hieronder volgt de lijst met alle klasse members met links naar de klasse documentatie voor elke member:" &gt;
&lt;!ENTITY trCompoundMembersDescriptionF "Hieronder volgt de lijst met alle gedocumenteerde klasse members met links naar de klassen waartoe ze behoren:" &gt;
&lt;!ENTITY trCompoundMembersDescriptionT "Hieronder volgt de lijst met alle klasse members met links naar de klasse documentatie voor elke member:" &gt;
&lt;!-- --&gt;
&lt;!ENTITY trFileMembersDescriptionFC "Hieronder volgt de lijst met alle gedocumenteerde file members met links naar de files waartoe ze behoren:" &gt;
&lt;!ENTITY trFileMembersDescriptionTC "Hieronder volgt de lijst met alle file members met links naar de file documentatie voor elke member:" &gt;
&lt;!ENTITY trFileMembersDescriptionF "Hieronder volgt de lijst met alle gedocumenteerde file members met links naar de files waartoe ze behoren:" &gt;
&lt;!ENTITY trFileMembersDescriptionT "Hieronder volgt de lijst met alle file members met links naar de file documentatie voor elke member:" &gt;
&lt;!-- --&gt;
&lt;!ENTITY trNamespaceListDescriptionF "Hier is een lijst met alle gedocumenteerde namespaces met voor elk een korte beschrijving:" &gt;
&lt;!ENTITY trNamespaceListDescriptionT "Hier is een lijst met alle namespaces met voor elk een korte beschrijving:" &gt;
&lt;!-- --&gt;
&lt;!ENTITY trNamespaceMemberDescriptionF "Hier is een lijst van alle gedocumenteerde namespace members met links naar de namespaces waartoe ze behoren:" &gt;
&lt;!ENTITY trNamespaceMemberDescriptionT "Hier is een lijst van alle namespace members met links naar de namespace documentatie voor iedere member:" &gt;
&lt;!-- --&gt;
&lt;!ENTITY trclass "klass" &gt;
&lt;!ENTITY trclasses "klassn" &gt;
&lt;!ENTITY trClass "Klasse" &gt;
&lt;!ENTITY trClasses "Klassen" &gt;
&lt;!-- --&gt;
&lt;!ENTITY trfile "file" &gt;
&lt;!ENTITY trfiles "files" &gt;
&lt;!ENTITY trFile "File" &gt;
&lt;!ENTITY trFiles "Files" &gt;
&lt;!-- --&gt;
&lt;!ENTITY trnamespace "namespace" &gt;
&lt;!ENTITY trnamespaces "namespaces" &gt;
&lt;!ENTITY trNamespace "Namespace" &gt;
&lt;!ENTITY trNamespaces "Namespaces" &gt;
&lt;!-- --&gt;
&lt;!ENTITY trgroup "groep" &gt;
&lt;!ENTITY trgroups "groepen" &gt;
&lt;!ENTITY trGroup "Groep" &gt;
&lt;!ENTITY trGroups "Groepen" &gt;
&lt;!-- --&gt;
&lt;!ENTITY trpage "pagina" &gt;
&lt;!ENTITY trpages "paginas" &gt;
&lt;!ENTITY trPage "Pagina" &gt;
&lt;!ENTITY trPages "Paginas" &gt;
&lt;!-- --&gt;
&lt;!ENTITY trmember "member" &gt;
&lt;!ENTITY trmembers "members" &gt;
&lt;!ENTITY trMember "Member" &gt;
&lt;!ENTITY trMembers "Members" &gt;
&lt;!-- --&gt;
&lt;!ENTITY trfield "veld" &gt;
&lt;!ENTITY trfields "velden" &gt;
&lt;!ENTITY trField "Veld" &gt;
&lt;!ENTITY trFields "Velden" &gt;
&lt;!-- --&gt;
&lt;!ENTITY trglobal "globale member" &gt;
&lt;!ENTITY trglobals "globale members" &gt;
&lt;!ENTITY trGlobal "Globale member" &gt;
&lt;!ENTITY trGlobals "Globale members" &gt;
&lt;!-- --&gt;
&lt;!ENTITY trauthor "auteur" &gt;
&lt;!ENTITY trauthors "auteurs" &gt;
&lt;!ENTITY trAuthor "Auteur" &gt;
&lt;!ENTITY trAuthors "Auteurs" &gt;
&lt;!-- --&gt;
&lt;!ENTITY trClassDocGeneratedFromFile "De documentatie voor deze class is gegenereerd op grond van de volgende file:" &gt;
&lt;!ENTITY trClassDocGeneratedFromFiles "De documentatie voor deze class is gegenereerd op grond van de volgende files:" &gt;

&lt;!ENTITY trStructDocGeneratedFromFile "De documentatie voor deze struct is gegenereerd op grond van de volgende file:" &gt;
&lt;!ENTITY trStructDocGeneratedFromFiles "De documentatie voor deze struct is gegenereerd op grond van de volgende files:" &gt;

&lt;!ENTITY trUnionDocGeneratedFromFile "De documentatie voor deze union is gegenereerd op grond van de volgende file:" &gt;
&lt;!ENTITY trUnionDocGeneratedFromFiles "De documentatie voor deze union is gegenereerd op grond van de volgende files:" &gt;

&lt;!ENTITY trInterfaceDocGeneratedFromFile "De documentatie voor deze interface is gegenereerd op grond van de volgende file:" &gt;
&lt;!ENTITY trInterfaceDocGeneratedFromFiles "De documentatie voor deze interface is gegenereerd op grond van de volgende files:" &gt;

&lt;!ENTITY trExceptionDocGeneratedFromFile "De documentatie voor deze exception is gegenereerd op grond van de volgende file:" &gt;
&lt;!ENTITY trExceptionDocGeneratedFromFiles "De documentatie voor deze exception is gegenereerd op grond van de volgende files:" &gt;
&lt;!-- --&gt;

------------------------------------------


&lt;!-- Template entities (or what should be) --&gt;

&lt;!ENTITY trDefinedAtLineInSourceFile "De definitie bevindt zich op regel @0 in de file @1." &gt;
&lt;!ENTITY trDefinedInSourceFile "De definitie bevindt zich in de file @0." &gt;
&lt;!ENTITY trFileReference "$1 File Referentie" &gt;
&lt;!ENTITY trNamespaceReference "$1 Namespace Referentie" &gt;
&lt;!ENTITY trCollaborationDiagram "Collaboratie diagram voor $1:" &gt;
&lt;!ENTITY trInclDepGraph "Include afhankelijkheidsgraaf voor $1:" &gt;
&lt;!ENTITY trPackage "Package $1" &gt;

&lt;!-- Sets of template entities --&gt;

&lt;!ENTITY trClassReference "$1  Class Referentie" &gt;
&lt;!ENTITY trClassTemplateReference "$1  Template Class Referentie" &gt;

&lt;!ENTITY trStructReference "$1  Struct Referentie" &gt;
&lt;!ENTITY trUnionReference "$1  Union Referentie" &gt;
&lt;!ENTITY trInterfaceReference "$1  Interface Referentie" &gt;
&lt;!ENTITY trExceptionReference "$1  Exception Referentie" &gt;

&lt;!-- Simple entities with fixed-name generated-entity references inside

&lt;!ENTITY trGeneratedAutomatically "Automatisch gegenereerd door Doxygen voor &amp;ProjName; uit de programmacode." &gt;
&lt;!ENTITY trGeneratedAt "Gegenereerd op &amp;GenDate; voor &amp;ProjName; door" &gt;
--&gt;

&lt;!-- ... but they can be also implemented as template entities)--&gt;

&lt;!ENTITY trGeneratedAutomatically "Automatisch gegenereerd door Doxygen voor $1 uit de programmacode." &gt;
&lt;!ENTITY trGeneratedAt "Gegenereerd op $1 voor $2 door" &gt;

&lt;!-- Simple fragments that should be converted to template entities --&gt;

&lt;!ENTITY trThisIsTheListOfAllMembers "Dit is de complete lijst van alle members voor" &gt;
&lt;!ENTITY trIncludingInheritedMembers ", inclusief alle overge&amp;euml;rfde members." &gt;

&lt;!-- should be converted to something like... --&gt;

&lt;!ENTITY trThisIsTheListOfAllMembers "Dit is de complete lijst van alle members voor$1." &gt;
&lt;!ENTITY trTheListOfAllMembersIncludingInherited "Dit is de complete lijst van alle members voor$1, inclusief alle overge&amp;euml;rfde members." &gt;

&lt;! --trWriteList() should be replaced using
     &amp;trLSep;, &amp;trLSepAnd2;, and &amp;trLSepAnd; entities

&lt;!ENTITY trWriteList1 "@0" &gt;
&lt;!ENTITY trWriteList2 "@0 en @1" &gt;
&lt;!ENTITY trWriteList3 "@0, @1 en @2" &gt;
--&gt;

&lt;!ENTITY trLSep ", " &gt;
&lt;!ENTITY trLSepAnd " en " &gt;
&lt;!ENTITY trLSepAnd2 " en " &gt;

&lt;!-- Should be normal entity templates instead using trWriteList inside --&gt;

&lt;!--
&lt;!ENTITY trInheritsList "Erft over van @0." &gt;
&lt;!ENTITY trInheritsList "Erft over van @0 en @1." &gt;
&lt;!ENTITY trInheritsList "Erft over van @0, @1 en @2." &gt;
--&gt;
&lt;!ENTITY trInherits "Erft over van $1." &gt;
&lt;!ENTITY trInheritsList "Erft over van $1." &gt;
&lt;!--
&lt;!ENTITY trInheritedByList "Wordt overge&amp;euml;rfd door @0." &gt;
&lt;!ENTITY trInheritedByList "Wordt overge&amp;euml;rfd door @0 en @1." &gt;
&lt;!ENTITY trInheritedByList "Wordt overge&amp;euml;rfd door @0, @1 en @2." &gt;
--&gt;
&lt;!ENTITY trInheritedBy "Wordt overge&amp;euml;rfd door $1." &gt;
&lt;!ENTITY trInheritedByList "Wordt overge&amp;euml;rfd door $1." &gt;
&lt;!--
&lt;!ENTITY trReimplementedFromList "Nieuwe implementatie van @0." &gt;
&lt;!ENTITY trReimplementedFromList "Nieuwe implementatie van @0 en @1." &gt;
&lt;!ENTITY trReimplementedFromList "Nieuwe implementatie van @0, @1 en @2." &gt;
--&gt;
&lt;!ENTITY trReimplementedFrom "Nieuwe implementatie van $1." &gt;
&lt;!ENTITY trReimplementedFromList "Nieuwe implementatie van $1." &gt;
&lt;!--
&lt;!ENTITY trReimplementedInList "Opnieuw ge&amp;iuml;mplementeerd in @0." &gt;
&lt;!ENTITY trReimplementedInList "Opnieuw ge&amp;iuml;mplementeerd in @0 en @1." &gt;
&lt;!ENTITY trReimplementedInList "Opnieuw ge&amp;iuml;mplementeerd in @0, @1 en @2." &gt;
--&gt;
&lt;!ENTITY trReimplementedIn "Opnieuw ge&amp;iuml;mplementeerd in $1." &gt;
&lt;!ENTITY trReimplementedInList "Opnieuw ge&amp;iuml;mplementeerd in $1." &gt;

&lt;!-- (end) --&gt;
</pre></div><h3><a name="DoxEntSummary"></a>
Summary of doxygen entity categories</h3>
The <em>simple entities</em> are also simple to implement. If doxygen did not use other kind of entities, then its implementation would probably be entity oriented from the beginning (i.e. symbols defined in textual files), wouldn't it be?<p>
The key part are the <em>template entities</em>, like the <code></code> . But see also that <code></code>  uses <code></code>  and <code></code>  markers. This is exactly what I mean by the template entity. So you definitely had the same idea earlier ;-)<p>
There is one stranger among the translator methods -- the  which generates a list of separated markers. Looking more carefully, it is clear that there are only three types of markers (English is typical):<ol>
<li>separator between the majority of a long list items (comma, space),</li><li>separator between the last and previous items in a long list (comma, space, <code>and</code>, space),</li><li>separator between items of a list with two elements (space, <code>and</code>, space -- no comma in English).</li></ol>
<p>
In Czech (and possibly in Dutch) the second and the third separators are the same. No problem here, different entities may have the same content.<p>
Having the three entities (I call them , , and  in that order), doxygen can generate any list in a language independent form like this:<p>
<div class="fragment"><pre>
  item1
  item1&amp;trLSepAnd2;item2
  item1&amp;trLSep;item2&amp;trLSepAnd;item3
</pre></div><p>
The language dependent form appears when the separator entities are replaced by the language dependent content, later.<p>
The whole list can be defined as the content of a generated entity, and the <code>trReimplementedFromList()</code> call can be replaced by the entity template application, like this:<p>
<div class="fragment"><pre>
  &lt;!ENTITY list001 "item1&amp;trLSep;item2&amp;trLSepAnd;item3" &gt;
  &lt;!ENTITY txt002 &lt;![CDATA[&lt;?doxtpl 
                  el="trReimplementedFromList" a1="&amp;list001;"?&gt;]]&gt; &gt;
</pre></div><p>
(The syntax of the  may not be in the final form.)<p>
Being defined this way, everything is still language independent. It becomes language dependent only in time when we decide to replace the entities by the language dependent definition of the content. It can look like this (Dutch example):<p>
<div class="fragment"><pre>
  &lt;!ENTITY trLSep ", " &gt;
  &lt;!ENTITY trLSepAnd  " en " &gt;
  &lt;!ENTITY trLSepAnd2 " en " &gt;
  &lt;!ENTITY trReimplementedFromList "Nieuwe implementatie van $1." &gt;
</pre></div><p>
and the language-dependent result will be obtained by the application of that template entity with argument <code></code> , and by replacement of the separator entities by the content.<h2><a name="DevelopmentStages"></a>
Development stages</h2>
I am going to sketch roughly the steps of implementation of the mechanism so, that the mechanism could be introduced gradually into doxygen. This should be the answer to <a class="el" href="index.html#Q4">the fourth question</a>.<p>
The development stages should include:<p>
<ul>
<li><a class="el" href="index.html#StudyXML">Gaining the XML-related knowledge</a></li><li><a class="el" href="index.html#FinishingThis">Finishing this document</a></li><li><a class="el" href="index.html#PreparingDoxygen">Preparing Doxygen for changes</a></li><li><a class="el" href="index.html#FindDevelopers">Search for developers (?)</a></li><li><a class="el" href="index.html#DefEntityFileSyntax">Syntax of files with entity definitions</a></li><li><a class="el" href="index.html#IDoxEntGenerator">Implement the generator of doxygen entities</a></li><li><a class="el" href="index.html#TranslatorExp">Implement the experimental translator</a></li><li><a class="el" href="index.html#ISimpleEnt">Implement simple entities</a></li><li><a class="el" href="index.html#ISimpleEntReplacement">Implement a simple entity replacement</a></li><li><a class="el" href="index.html#ITemplateEnt">Implement template entities</a></li><li><a class="el" href="index.html#IApplicTemplate">Application of template entities</a></li><li><a class="el" href="index.html#NewTranslator">Introduce the new, single Translator class</a></li><li><a class="el" href="index.html#SupportScript">Implement the script for maintenance</a></li><li><a class="el" href="index.html#RemovingTranslator">Remove the Translator class</a></li></ul>
<h3><a name="StudyXML"></a>
Gaining the XML-related knowledge</h3>
Firstly, we should learn the things that could be related to the implementation. The reason is to avoid reinventing the wheel and to decide what can be reused. The experience should be summarized in this document so, that others could say what they think about it.<h3><a name="FinishingThis"></a>
Finishing this document</h3>
Then we should put together what we know, write it down, polish it a bit in this document. Then the document should be sent into Doxygen-develop mailing list, and probably also send it to all people involved in the development.<p>
Part of the polishing would be to remove "I think"'s and "you could"'s and make the sentences readable for wider audience.<h3><a name="PreparingDoxygen"></a>
Preparing Doxygen for changes</h3>
<ol>
<li>
We should start with changes of current doxygen translator to <em>remove the exceptions</em> like <code>trWriteList()</code> and <code>trDefinedAtLineInSourceFile()</code> (the markers replaced in the core).<p>
All the methods should belong to one of the cases described in <a class="el" href="index.html#CurrentMechanismAnalysis">The analysis of the curent mechanism</a>. The <code>TranslatorAdapter_x_y_z</code> should be able to capture the changes. Even the <code>trLSep()</code>, <code>trLSepAnd()</code>, and <code>trLSepAnd2()</code> can be implemented via analysis of the <code>trWriteList()</code> results (and optimized via storing the strings into member variables). Similarly, the adapter could generate template strings from methods like <code>trDefinedAtLineInSourceFile()</code>.<p>
</li>
<li>
The <code>Init()</code> method should be introduced to the <code>Translator</code> class. It will be called to load and parse the entity definition file. It probably should have at least one argument (string) to pass the name of the requested language.<p>
</li>
<li>
<a name="solution_optimc"/></a> <b></b>(Solved) Methods that used <code>Config_getBool()</code> to recognize the C versus C++ or Java flavours were split to pairs of methods (this will probably be introduced in version 1.2.11). The flavour recognition was moved to the core. <a class="el" href="index.html#solution_optimc_skipper">(Skip the solution explanation)</a>.<p>
Using <code>Config_getBool()</code> inside the Translator methods was a big obstackle for <a class="el" href="index.html#GenerDoxEntities">Automatic generation of doxygen entities</a>. The reason was that it was impossible to call those translator methods with any arguments to obtain the entity or template string other than the one of the current flavour (option <code>"OPTIMIZE_OUTPUT_FOR_C"</code> in <code>Doxyfile</code>).<p>
<b>Firstly</b>, the translator methods that called the <code>Config_getBool</code>("OPTIMIZE_OUTPUT_FOR_C") were split to pairs. One of the new methods works for C optimization, the other for the C++ optimization. The methods were given names that do not cause collision with the earlier defined methods. Even the original identifier was not reused, because it would break the translator adapters.<p>
<b>Secondly</b>, the new source files <code>optimc.h</code> and <code>optimc.cpp</code> were introduced to implement the <code>"OPTIMIZE_OUTPUT_FOR_C"</code> recognition, and to call one of the new translator methods. The code typically looks this way:<p>
<div class="fragment"><pre>    QCString trMemberDataDocumentation()
    {
      <span class="keywordflow">return</span> Config_getBool(<span class="stringliteral">"OPTIMIZE_OUTPUT_FOR_C"</span>)
               ? theTranslator-&gt;trFieldDocumentation()
               : theTranslator-&gt;trMemberDataDocumentationCpp();
    }    
</pre></div><p>
The identifier of the function (including possible arguments) is the same as the one used for the older translator method. This means that the core sources (i.e. not translators) could be changed easily. For example, the <code>classdef.cpp</code> source contained earlier the following command:<p>
<div class="fragment"><pre>      variableMembers.writeDocumentation(ol,name(),<span class="keyword">this</span>,
                         theTranslator-&gt;trMemberDataDocumentation());
</pre></div><p>
This was changed by simply including the <code>optimc.h</code> header file and by removing the <code>"theTranslator-&gt;"</code> sequence.<p>
<div class="fragment"><pre><span class="preprocessor">    #include "optimc.h"</span>
    ...
      
      variableMembers.writeDocumentation(ol,name(),<span class="keyword">this</span>,
                         trMemberDataDocumentation());
</pre></div><p>
This way the <code>"OPTIMIZE_OUTPUT_FOR_C"</code> recognition was effectively moved from translators to the core code. The abstract class <code>Translator</code> was updated -- older methods were removed, new included as required methods. In the same time, the <code>TranslatorEnglish</code> was updated to implement the changes.<p>
<b>Thirdly</b>, the translator adapter classes were updated so, that the translators for other languages worked as if nothing happened. This was done by fooling them that <code>Config_getBool</code>("OPTIMIZE_OUTPUT_FOR_C") still work. The trick is that it now does not return the status of the option from <code>Doxyfile</code>. Instead, it returns the value of the member variable of the translator adapter class. The <code>Config_getBool()</code> is originally the macro defined in <code>config.cpp</code>. Because of this, it must be undefined for the translators first. Then we can write:<p>
<div class="fragment"><pre><span class="preprocessor">    #undef Config_getBool</span>
<span class="preprocessor"></span>    ...
    
    <span class="keyword">protected</span>:
  
      <span class="keywordtype">bool</span> Config_getBool(<span class="keyword">const</span> <span class="keywordtype">char</span> *)
      {
          <span class="keywordflow">return</span> m_bOptimizeOutputForC;
      }
     
    <span class="keyword">private</span>:
     
      <span class="keywordtype">bool</span> m_bOptimizeOutputForC; 
</pre></div><p>
The function <code>Config_getBool()</code> takes always the value "OPTIMIZE_OUTPUT_FOR_C" as the argument in the TranslatorXxxx classes. The trick is to return the value of the member variable instead of the value defined in Doxyfile. It must be accessible from the derived classes -- hence protected.<p>
The m_bOptimizeOutputForC variable defines the status for the Config_getBool() method. It is used only by the adapter class -- hence private. We can think about setting the value of the variable as about rather complicated way of passing the value to the place where the Config_getBool() is called (inside the translator methods).<p>
Defining the Config_getBool() method this way means that the <em>adapter</em> <em>method's</em> <code>Config_getBool()</code> will be called inside the translator methods instead of the <em>global</em> <em>function</em>. The souces of language translators need not to be touched.<p>
Then, the translator adapter can implement the new translator methods via calling the implemented older one this way:<p>
<div class="fragment"><pre>    <span class="comment">// the old one</span>
    <span class="keyword">virtual</span> QCString trMemberDataDocumentation()
    {
      <span class="keywordflow">if</span> (m_bOptimizeOutputForC)
      {
        <span class="keywordflow">return</span> <span class="stringliteral">"Field Documentation"</span>; 
      }
      <span class="keywordflow">else</span>
      {
        <span class="keywordflow">return</span> <span class="stringliteral">"Member Data Documentation"</span>; 
      }

    }

    <span class="comment">// the new one -- first of the pair</span>
    <span class="keyword">virtual</span> QCString trMemberDataDocumentationCpp()
    { 
      m_bOptimizeOutputForC = <span class="keyword">false</span>;
      <span class="keywordflow">return</span> trMemberDataDocumentation();  
    }
   
    <span class="comment">// the new one -- second of the pair</span>
    <span class="keyword">virtual</span> QCString trFieldDocumentation()
    { 
      m_bOptimizeOutputForC = <span class="keyword">true</span>;
      <span class="keywordflow">return</span> trMemberDataDocumentation();
    }
</pre></div><p>
Notice that the <code>trMemberDataDocumentation()</code> (the old one) is virtual, so the language specific version will be called. However, translator adapter have to implement it also, because the new methods are implemented via calling the old one, and the old method is already not defined in the Translator class (pure virtual). In other words, it is obsolete, but needed by the translator adapter.<p>
The flavour (optimized for C or C++) is not determined by the <code>Doxyfile</code> <em>inside the translator classes</em> any more. This means that we can always call for example <code>trFieldDocumentation()</code>, independently on what is set in <code>Doxyfile</code>. This is the key for the <a class="el" href="index.html#GenerDoxEntities">Automatic generation of doxygen entities</a>. The core code decides (based on testing the value from inside <code>Doxyfile</code>) whether it will call the <code>trFieldDocumentation()</code> or not.<p>
<a name="solution_optimc_skipper"/></a><p>
</li>
<li>
The methods like <code>trCompoundReference()</code> could be split. Passing the <code>Classdef::Xxxx</code> argument should be replaced by decision what method will be called.<p>
There is high probability that this will be done during the step when the code approach will be replaced by the entity approach. In other words, we should do some revision of the used entities and of the used templates and decide what will be changed and what will be the names of the entities. The conversion from the methods to the entities will be done <a class="el" href="index.html#GenerDoxEntities">automatically</a> via several calls to the method with different arguments. </li>
</ol>
<h3><a name="FindDevelopers"></a>
Search for developers (?)</h3>
When publishing this document in Doxygen-develop, we should ask what other think about the idea, who has some related knowledge, and who could participate on the development. (This is not clear yet. It may be better to start single and search for participants later, when the task can be divided.) Some notice could be also sent to Doxygen-users.<h3><a name="DefEntityFileSyntax"></a>
Syntax of files with entity definitions</h3>
The syntax of the entity definitions will follow the XML way. When the entity defines more lines, the CDATA will be used, like this:<p>
<div class="fragment"><pre>
  &lt;!ENTITY trEntityId "one-line content" &gt;
  
  &lt;!ENTITY trEtityMulti &lt;![CDATA[First line of the multiline entity definition.
Second line.
Third line, etc.]]&gt; &gt;
</pre></div><p>
The CDATA syntax can be prefered also when we do not want to convert special characters to entity references (like &lt; to &amp;lt;).<p>
To make distribution of doxygen easier, the image of those files could be compiled into the doxygen (as in the java script case). At least, it should be done for English. Doxygen, when started, should look for the <code>*</code>.ent files in its directory. If they are not present here, the files will be generated. If they are present, no generation will happen. This way, newer files can be downloaded (or the old updated manually) and they will be used instead the compiled-in definitions.<h3><a name="IDoxEntGenerator"></a>
Implement the generator of doxygen entities</h3>
When the syntax of the files is decided, the program mentioned in <a class="el" href="index.html#GenerDoxEntities">Automatic generation of doxygen entities</a> could be polished so that it could generate such files for all languages.<p>
At the beginning, it must generate reliably only some selected entities. Later, it will be updated depending on requirements of further development stages.<h3><a name="TranslatorExp"></a>
Implement the experimental translator</h3>
The first development steps should start by adding <code>TranslatorExperimental</code> class as if it was another language translator. In other words, no difference should be observed by the doxygen kernel. This <code>TranslatorExperimental</code> should gradually introduce the mechanisms of working with the entities. I would recommend to create is as a copy of TranslatorEnglish.<p>
Then we should introduce some method like <code>Init</code>("dutch") that would read the file with definitions for that language into internal structures. Here the file will be parsed. Here the syntax used in the file will be last point where the syntax of files is important for further steps. Here also a possible conversion of character encoding should happen (see the <code>decode()</code> inline in <code>TranslatorCzech</code> and others).<h3><a name="ISimpleEnt"></a>
Implement simple entities</h3>
We will choose some very simple <code>trMethod()</code> that returns only one simple and constant string (i.e. with no arguments). Its body will test the algorithm for retrieving the string based on the name of the related entity.<p>
Then the code around the <code>TranslatorExperimental</code> can be slightly changed so, that we could write something like that into <code>Doxyfile</code>: <div class="fragment"><pre>
  OUTPUT_LANGUAGE = Experimental Dutch
</pre></div><p>
It should be very simple. Just after instantiation of the <code>TranslatorExperimental</code>, its <code>Init</code>("dutch") will be called.<p>
This way, the chosen <code>trMethod()</code> becomes multilingual -- based on the initialization. (See <a class="el" href="index.html#NewTranslator">the final goal</a>.)<p>
This stage should implement and test the structures for searching for the entity content. Also, this should help to decide the basic syntax of the entity definitions in the text file. Probably (with respect to future), the best way will be to adopt the simplified XML way.<h3><a name="ISimpleEntReplacement"></a>
Implement a simple entity replacement</h3>
Here the mechanism of defining a simple entity using other simple entities could be tested. The goal will be to replace the entity reference inside another simple entity definition so that it behaved as if the content of the outer entity was defined without using another simple entity reference. The example should clarify that. Say, we have definitions of simple entities like that:<p>
<div class="fragment"><pre>
&lt;!ENTITY trClassDocGeneratedFromFile "De documentatie voor deze class is gegenereerd op grond van de volgende file:" &gt;
&lt;!ENTITY trClassDocGeneratedFromFiles "De documentatie voor deze class is gegenereerd op grond van de volgende files:" &gt;
&lt;!ENTITY trStructDocGeneratedFromFile "De documentatie voor deze struct is gegenereerd op grond van de volgende file:" &gt;
&lt;!ENTITY trStructDocGeneratedFromFiles "De documentatie voor deze struct is gegenereerd op grond van de volgende files:" &gt;
&lt;!ENTITY trUnionDocGeneratedFromFile "De documentatie voor deze union is gegenereerd op grond van de volgende file:" &gt;
&lt;!ENTITY trUnionDocGeneratedFromFiles "De documentatie voor deze union is gegenereerd op grond van de volgende files:" &gt;
&lt;!ENTITY trInterfaceDocGeneratedFromFile "De documentatie voor deze interface is gegenereerd op grond van de volgende file:" &gt;
&lt;!ENTITY trInterfaceDocGeneratedFromFiles "De documentatie voor deze interface is gegenereerd op grond van de volgende files:" &gt;
&lt;!ENTITY trExceptionDocGeneratedFromFile "De documentatie voor deze exception is gegenereerd op grond van de volgende file:" &gt;
&lt;!ENTITY trExceptionDocGeneratedFromFiles "De documentatie voor deze exception is gegenereerd op grond van de volgende files:" &gt;
</pre></div><p>
Of course, the maintainer should be a bit lazy to type ;-) The argument sounds better when we say that the maintainer tries to make the definitions consistent. He/she can decide to introduce new simple entity definitions to simplify the definitions of the obligatory entities, like this:<p>
<div class="fragment"><pre>
&lt;!ENTITY DeDocVoorDeze "De documentatie voor deze" &gt;
&lt;!ENTITY IsGegenVanFile "is gegenereerd op grond van de volgende file:" &gt;
&lt;!ENTITY IsGegenVanFiles "is gegenereerd op grond van de volgende files:" &gt;

&lt;!ENTITY trClassDocGeneratedFromFile "&amp;DeDocVoorDeze; class &amp;IsGegenVanFile;" &gt;
&lt;!ENTITY trClassDocGeneratedFromFiles "&amp;DeDocVoorDeze; class &amp;IsGegenVanFile;" &gt;
&lt;!ENTITY trStructDocGeneratedFromFile "&amp;DeDocVoorDeze; struct &amp;IsGegenVanFile;" &gt;
&lt;!ENTITY trStructDocGeneratedFromFiles "&amp;DeDocVoorDeze; struct &amp;IsGegenVanFiles;" &gt;
&lt;!ENTITY trUnionDocGeneratedFromFile "&amp;DeDocVoorDeze; union &amp;IsGegenVanFile;" &gt;
&lt;!ENTITY trUnionDocGeneratedFromFiles "&amp;DeDocVoorDeze; union &amp;IsGegenVanFiles;" &gt;
&lt;!ENTITY trInterfaceDocGeneratedFromFile "&amp;DeDocVoorDeze; interface &amp;IsGegenVanFile;" &gt;
&lt;!ENTITY trInterfaceDocGeneratedFromFiles "&amp;DeDocVoorDeze; interface &amp;IsGegenVanFiles;" &gt;
&lt;!ENTITY trExceptionDocGeneratedFromFile "&amp;DeDocVoorDeze; exception &amp;IsGegenVanFile;" &gt;
&lt;!ENTITY trExceptionDocGeneratedFromFiles "&amp;DeDocVoorDeze; exception &amp;IsGegenVanFiles;" &gt;
</pre></div><p>
The replacement shoud be automatic. Here the decision will be taken and tested when the simple entity references should be expanded -- greedy or lazy evaluation of the entities ;-)<h3><a name="ITemplateEnt"></a>
Implement template entities</h3>
Here the syntax of simple template entities will be introduced to be stored in the entity definition text file. Basically, the template entity should be stored the same way as non-template entity. The only difference is that it contains also markers like <code>$1</code>, <code>$2</code>, etc. What makes the template entity differen from the other entities will be its usage or <a class="el" href="index.html#IApplicTemplate">application</a>.<p>
In this step, the mechanism of replacement will be implemented and tested inside the chosen <code>trMethod()</code>. It will simply search the markers and replace them with the arguments.<h3><a name="IApplicTemplate"></a>
Application of template entities</h3>
In this step, the marker-replacement mechanism should be moved to the general part of the code. The chosen method will only prepare the name of the template entity and the arguments. Then it will call the replacement code to get the string. The call may look like this:<p>
<div class="fragment"><pre>
  theTranslator-&gt;DoxTpl("trReimplementedFromList", "&amp;list001;"); 
</pre></div><p>
Firstly, the <code>trReimplementedFromList</code> template entity string (with markers) will be retrieved; then the arguments will be used to replace the markers.<p>
As the method should return the language dependent string, the replacement of simple entities should also be done inside. (Think about <code></code>  in the above example or about some other entity reference placed in the template entity string.)<p>
Later, when <a class="el" href="index.html#NewTranslator">new Translator</a> will be removed, the application of the template entities will be implemented inside the replacement mechanism. The command for the template application can take the form of XML procesing instruction, and can be stored as some other entity definition. As XML processing instructions contain special character, the CDATA block syntax is used:<p>
<div class="fragment"><pre>
  &lt;!ENTITY txt002 &lt;![CDATA[&lt;?doxtpl 
                               tpl="&amp;trReimplementedFromList;"
                               a1="&amp;list001;" ?&gt; 
                  ]]&gt;
</pre></div><p>
Here, the example slightly differs from the one <a class="el" href="index.html#DoxEntSummary">above</a>. The syntax shown here is probably better. The expansion of entity references should happen first and the replacement later. This would give us also a possibility to use it for cases when the template or the argument (or both) are not stored as entity definitions:<p>
<div class="fragment"><pre>
  &lt;!ENTITY txt002 &lt;![CDATA[&lt;?doxtpl 
                  tpl="My template with argument '$1' is used here."
                  a1="MY ARGUMENT" ?&gt; 
                  ]]&gt;
</pre></div><p>
Or the sequence can be used directly in some text, i.e. not via referencing <code></code> .<p>
It seems that the processing instructions are the right thing that we need because they are able to capture some special functionality (done by the named code with given arguments). If we once move more closely to XML, then doxtpl will be very simple external application that just do the replacement of markers by the arguments. This way, general XML tools may be given language independent document sources and the language dependent entity definitions. The replacement will happend during conversion (XSLT) of the sources into another form (for example into HTML).<p>
The reason for postponing the replacement as late as possible is, that the <code>doxtpl</code> processing instruction may still have language-independent form. The language dependent form may be produced by general XML tools. While this may not be the goal now, it can be handy in future.<p>
<b>Conclusion:</b> The mechanism of the template application should be implemented gradually this way:<p>
<ol>
<li>Explicit call of <code>theTranslator-&gt;DoxTpl()</code>, as shown above.</li><li>Generation of the processing instruction inside the chosen <code>trMethod()</code> and explicit calling <div class="fragment"><pre> theTranslator-&gt;ProcInstruction(<span class="stringliteral">"&lt;?doxtpl ....?&gt;"</span>);
</pre></div></li><li>Defining new entity with the <code>doxtpl</code> processing instruction and explicit calling the method which does replacement (i.e. processing instruction recognition will be added to the replacement mechanism). So the chosen <code>trMethod</code> will define the procesing instruction and invoke the general replacement code, not the <code>ProcInstruction()</code>.</li><li>As the processing instruction looks like the method call (i.e. name and arguments), it can be generated directly of via entity definition into the intermediate form of the document. The previously chosen <code>trMethod()</code> can be completely removed from the <a class="el" href="index.html#NewTranslator">new translator</a> during the <a class="el" href="index.html#RemovingTranslator">translator removal</a> stage.</li></ol>
<p>
Concerning the last point, this can also be interpreted so, that the previous <code>trMethod()</code> call will be replaced inside doxygen by forming the processing instruction (deciding name of the template and preparing arguments is similar to calling the method) and calling the code that finally will be implemented by doxygen core.<h3><a name="NewTranslator"></a>
Introduce the new, single Translator class</h3>
Finally, the <code>TranslatorExperimental</code> will implement all <code>trMethods()</code>. In that time, it will replace the functionality of all the other language translators and the language dependent classes will be removed. The language maintainers will be given the generated language dependent files to be maintained (instead the code).<p>
The English entity definitions can always be loaded first, the desired language definitions can be loaded after. This way, definitions for all used entities will be present.<p>
It could be enhanced later so, that <code>adapter_x_y_z.def</code> entity definitions will be loaded if some entity is not found.<h3><a name="SupportScript"></a>
Implement the script for maintenance</h3>
The equivalent of the <code>translator.pl</code> will be implemented to support the language maintenance.<p>
Firstly, how <code>translator.pl</code> is implemented. The key here is to analyze source code of the abstract class <code>Translator</code> in <code>Translator.h</code>. When we extract all pure virtual methods, we have the list of methods that must be implemented. Then we extract all virtual methods from the chosen <code>TransatorLanguage</code> class. After comparison of the two lists we know what methods are implemented, what are not (they are implemented by some <code>TranslatorAdaper</code>), and what are implemented but not used (the obsolete methods). The status of the <code>TranslatorLanguage</code> is extracted from the identifier of its base class.<p>
Similarly, when the entities will be used, one of the set of definitions (the English one) will be considered as the reference set. XML comments will be used what definitions belong to what version of doxygen. Another form of comments will be used to exclude some entity identifiers from the required set. It will name entities that are used only for easier definition of other entities -- see notices about <a class="el" href="index.html#ISimpleEntReplacement">the replacement</a> of entity references inside other entity definitions. This way, the script can extract the names of entities that are required by doxygen, and since what version they are required.<p>
From definitions of the tested language, all entity names will be extracted (and possibly also number of replacement marks inside template entities), and the second list will be build. If some of the entities are not required (not listed in the previous list), and if references to them are not used inside definitions of the requested entities, then they will be considered obsolete. The entities that are in the first list but not in the second list imply that the language should be updated. The minimum of the version numbers related to the missing entities will be said to be language maintenance status.<h3><a name="RemovingTranslator"></a>
Remove the Translator class</h3>
Wherever doxygen core (generators) call <code>Translator::trMethod()</code>, the code will generate the equivalent entity reference.<p>
The entity definitions could be redesigned. The <code>trMethods()</code> will be gradually removed from the new <code>Translator</code> class.<p>
After testing, the whole generalized mechanism for working with entities could be moved to the doxygen core (generators). The translator class will be completely removed.<hr><address style="align: right;"><small>Generated on Fri Mar 14 14:45:28 2003 for Translators Revisited by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 
width=110 height=53></a>1.3-rc3-20030308 </small></address>
</body>
</html>
